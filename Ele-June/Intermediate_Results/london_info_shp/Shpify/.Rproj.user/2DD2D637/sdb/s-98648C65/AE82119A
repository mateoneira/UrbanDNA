{
    "collab_server" : "",
    "contents" : "install.packages(c(\"ggplot2\", \"gstat\", \"sp\", \"maptools\",\"gdal\"))\nrequire(ggplot2)\nrequire(rgeos)\nrequire(gstat) \nrequire(rgdal)\nrequire(sp)\nrequire(maptools)\nrequire(readxl)\nrequire(dplyr)\ngetwd()\ndf<-read.csv(\"london_info.csv\")\nView(df)\n\n############### I. GET THE DOTS ############################\ncoordinates(df) <- ~X+Y\nplot(df)\n\nsummary(df)\n\n# notGrid<-read.csv(\"/Users/June/Desktop/Data Capture/DNA/June's Part/June's Data/COA2011 AvPTAI2015.csv\")\n# View(notGrid)\n\n\n\n############### II. create grids ############################\n\nx.range <- as.integer(range(df@coords[,1]))\ny.range <- as.integer(range(df@coords[,2]))\ngrd <- expand.grid(x=seq(from=x.range[1], to=x.range[2], by=20), y=seq(from=y.range[1], to=y.range[2], by=20))\nplot(grd)\n\n\n## convert grid to SpatialPixel class\ncoordinates(grd) <- ~ x+y\ngridded(grd) <- TRUE\n\n## test it out - this is a good way of checking that your sample points are all well within your grid. If they are not, try some different values in you r x and y ranges:\nplot(grd, cex=0.01)\npoints(df, pch=1, col='red', cex=0.01)\ntitle(\"Interpolation Grid and Sample Points\")\n\n\n######### III. Inverse Distance Weighting ###########################\nidw<-idw(formula=AI2015 ~ 1, locations=df, newdata=grd)\nidw.output=as.data.frame(idw)\nnames(idw.output)[1:3]<-c(\"long\",\"lat\",\"var1.pred\")\n# View(idw.output)\n#plot(x=idw.output$long,y=idw.output$lat,fill=idw.output$var1.pred)\n\nplot<-ggplot(data=idw.output,aes(x=long,y=lat))#start with the base-plot \nlayer1<-c(geom_tile(data=idw.output,aes(fill=var1.pred)))#then create a tile layer and fill with predicted values\n#layer2<-c(geom_path(data=boroughoutline,aes(long, lat, group=group),colour = \"grey40\", size=1)\nplot+layer1+scale_fill_gradient(low=\"#FEEBE2\", high=\"#7A0177\")\n\n########################## Well. shapefile... merging with attribute code. ##########################################\n### 1. link borough code with shapefile. INCOME.\nboroughs.shp<-readOGR(\"/Users/June/urbanDNA/Ele-June/June's Data/ESRI/London_Borough_Excluding_MHW.shp\")\nView(boroughs)\n\nincome <-read.csv(\"/Users/June/urbanDNA/data/Income_and_HousingValue_2009.csv\",encoding=\"UTF-8\")\nView(income)\n\nincome$NAME<-gsub('_',\" \",income$Borough)\n#income<-cbind(income('NAME','Median_Weekly_Household_Income_.2009.'))\nmerged<-merge(boroughs.shp, income)\nView(merged)\nmerged<-merged[-c(8,9,11:14)]\n\nView(merged)\n?writeOGR\nwriteOGR(obj=merged, dsn=\"Shapefiles\", layer=\"income\", driver=\"ESRI Shapefile\")\n########################## the line to run if restarting session################################\ntest <-readOGR(\"/Users/June/Desktop/Data Capture/DNA/June's Part/income_Shapefiles/income.shp\")\n###########################################################################################\n\n\n\nView(test)\n\n\n# the fortified shapefile. with attributes added as well\nxy<-fortify(test,region = \"NAME\")\nsp_merge<-merge(xy,test,by.x=\"id\",by.y=\"NAME\")\nsp_merge$M_W_H_I<-as.numeric(sp_merge$M_W_H_I)\n\nggplot()+geom_path(data = sp_merge,aes(x=long,y=lat,group=group,fill=sp_merge$M_W_H_I))\n\n# write out the csv.\nclass(sp_merge)\nwrite.csv(sp_merge,file=\"houseIncome\")\n\n#### simulate another boundary...\ntest<-read.csv(\"houseIncome.csv\")\nView(test)\n\n\n\n#### 2. PTAL \n# not grid form of PTAL\nPTAL_ng <-read.csv(\"/Users/June/Desktop/Data Capture/DNA/June's Part/June's Data/COA2011 AvPTAI2015.csv\")\nView(PTAL_ng)\n\n## found 2011 COA boundary shapefile. \nlondon0A<-readOGR(\"/Users/June/Desktop/Data Capture/DNA/June's Part/June's Data/ESRI/OA_2011_London_gen_MHW.shp\")\nView(london0A) ## it's really comprehensive OA<-WARD<-BOROUGH DATA...\n\nlondonPTAL_OA<-merge(london0A,PTAL_ng,by.x=\"OA11CD\",by.y=\"COA2011\", all.x =FALSE)\nlondonPTAL_OA<-londonPTAL_OA[,-c(2:14,16:17)] #hence the resultant shapefil has OA code, pop density, PTAL\nclass(londonPTAL_OA)\nView(londonPTAL_OA)\n################### logic of overlay interpolation between areas ####################################\n# initial / source boudary with attributes column\n#here test = merged\nsc_boundary\nView(sc_boundary)\n######### 1. create /simulate another boundary shapefile       #################\n# (will need to get it from the boundary points ele produced. reverse process of fortify.)\n## here, use OA.\ntg_boundary_sub<-londonPTAL_OA[1:500,]\n\n\n######### 2. calculate.. for each new polygon, its composition. sum up. #################\n\n## testing intersection and area ##\n# ?gIntersection\n\ninter2=gIntersection(tg_boundary_sub[2,], sc_boundary[2,])\nis.null(inter2)\n\n# inter2\n# # plot(inter2)\n#  gArea(inter2)\n# inter2\n# if(!is.null(inter2)){print('NULL')}\n# ?area.poly\n# plot(tg_boundary_sub[1:8,])\n# plot(sc_boundary[1,])\n\n\n## to avoid projection error.\nis.projected(tg_boundary_sub)\nis.projected(sc_boundary)\nsc_boundary@proj4string <-tg_boundary_sub@proj4string\ntg_boundary_sub@proj4string\nidentical(sc_boundary@proj4string,tg_boundary_sub@proj4string)\n\n\n## export the shapefiles for testing in python\n\nwriteOGR(obj=sc_boundary, dsn=\"sc_boundary\",layer=\"sc_boundary\",driver=\"ESRI Shapefile\")\nwriteOGR(obj=tg_boundary_sub, dsn=\"tg_boundary\", layer=\"tg_boundary\", driver=\"ESRI Shapefile\")\n\nsc_values<-as.numeric(sc_boundary$M_W_H_I)\n### for loop to calculate overlay weighted \ntg_zone_value<-array()\nfor(i in 1:length(tg_boundary_sub)){\n  value<-0\n  for (j in 1:length(sc_boundary)){\n    inters<-gIntersection(sc_boundary[j,],tg_boundary_sub[i,])\n    if(!is.null(inters)){\n      inters_ratio<-gArea(inters)/gArea(tg_boundary_sub[i,])\n      sc_attr_val<-sc_values[j] #8 because column 8 is the attribute we need to extract\n      inters_wt <-inters_ratio*sc_attr_val ## weighted intersection\n    }else{inters_wt<-0}#if not intersecting then sc[j]'s contribution is zero\n    # increment tg_zone_value\n    value<-value+inters_wt\n  }\n  \n  tg_zone_value[i]<-value\n}\n  \ntg_zone_value #\"interpolated value returned. in order. hence can be attached back to dataframe.\n\n\n",
    "created" : 1495280874845.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "232120726",
    "id" : "AE82119A",
    "lastKnownWriteTime" : 1494528641,
    "last_content_update" : 1495281049159,
    "path" : "~/Desktop/Data Capture/DNA/Shpify/Untitled.R",
    "project_path" : "Untitled.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}